<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-reddy-add-server-selection-07"
     ipr="trust200902">
  <front>
    <title abbrev="DNS Server Info with Assertion Token">DNS Server Selection:
    DNS Server Information with Assertion Token</title>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="McAfee">McAfee, Inc.</organization>

      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560071</code>

          <country>India</country>
        </postal>

        <email>kondtir@gmail.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <country>USA</country>
        </postal>

        <email>dwing-ietf@fuggles.com</email>
      </address>
    </author>

    <author fullname="Michael C. Richardson" initials="M."
            surname="Richardson">
      <organization>Sandelman Software Works</organization>

      <address>
        <postal>
          <street></street>

          <country>USA</country>
        </postal>

        <email>mcr+ietf@sandelman.ca</email>
      </address>
    </author>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <date />

    <workgroup>ADD WG</workgroup>

    <abstract>
      <t>The document defines a mechanism that is meant to communicate DNS
      resolver information to DNS clients for use as a criteria for server
      selection decisions. In particular, the document defines a mechanism for
      a DNS server to communicate its filtering behavior to DNS clients. Such
      an information that is cryptographically signed to attest its
      authenticity is used for the selection of DNS resolvers. Typically,
      evaluating the filtering behavior and the signatory, DNS clients with
      minimal or no human intervention can select the DNS servers for
      resolving domain names.</t>

      <t>This assertion is useful for encrypted DNS (e.g., DNS-over-TLS,
      DNS-over-HTTPS, or DNS-over-QUIC) servers that are either public
      resolvers or discovered in a local network.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t><xref target="RFC7626"></xref> discusses DNS privacy considerations
      in both "on the wire" (Section 2.4 of <xref target="RFC7626"></xref>)
      and "in the server" (Section 2.5 of <xref target="RFC7626"></xref>)
      contexts. Examples of protocols that provide encrypted channels between
      DNS clients and servers are DNS-over-HTTPS (DoH) <xref
      target="RFC8484"></xref>, DNS-over-TLS (DoT) <xref
      target="RFC7858"></xref>, and DNS-over-QUIC (DoQ) <xref
      target="I-D.ietf-dprive-dnsoquic"></xref>.</t>

      <t>DNS clients can discover and authenticate encrypted DNS servers
      provided by a local network, for example using the techniques proposed
      in [I-D.ietf-add-dnr] and [I-D.ietf-add-ddr]. If the mechanism used to
      discover the encrypted DNS server is insecure, the DNS client needs
      evidence about the encrypted server to assess its trustworthiness and a
      way to appraise such evidence. The mechanism specified in this document
      can be used by the DNS client to cryptographically identify if it is
      connecting to an encrypted DNS server hosted by a specific organization
      (e.g., ISP or Enterprise). This strengthens the protection as clients
      can detect and reject connections to encrypted DNS servers hosted by
      attackers.</t>

      <t>This document also defines a mechanism for DNS clients to gather a
      set of resolver information related to discovered (or preconfigured) DNS
      servers and use that information to feed a DNS server selection
      procedure.</t>
    </section>

    <section anchor="notation" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref><xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>This document makes use of the terms defined in <xref
      target="RFC8499"></xref> and <xref
      target="I-D.ietf-dnsop-terminology-ter"></xref>.</t>

      <t>'Encrypted DNS' refers to a DNS protocol that provides an encrypted
      channel between a DNS client and server (e.g., DoT, DoH, or DoQ).</t>

      <t>The terms 'Evidence', 'Verifier', 'Background Check', 'Relying
      Party', 'Appraisal Policy', and 'Attestation Results' are defined in
      <xref target="I-D.ietf-rats-architecture"></xref>.</t>
    </section>

    <section anchor="PAT" title="Resolver Assertion Token (RAT): Overview">
      <t>The mechanism used in this specification resembles the
      Background-Check Model discussed in Sections 5.2 and 5.3 of Remote
      attestation procedure (RATS) Architecture <xref
      target="I-D.ietf-rats-architecture"></xref>. RATS enables a relying
      party to establish a level of confidence in the trustworthiness of a
      remote peer through the creation of Evidence to assess the peer's
      trustworthiness, and an Appraisal Policy for such Evidence.</t>

      <t>In this document, the Relying Party is the DNS client and the
      Attester is the encrypted DNS server. The Encrypted DNS servers MAY use
      "Domain Validation" (DV) certificates for certificate-based server
      authentication in TLS connections.</t>

      <t>The DNS server's resolver information needs to be validated and
      signed. This signature is called an <xref
      target="I-D.ietf-rats-architecture">Attestation Result</xref>. This
      validation can be performed by the DNS operator itself (signed by the
      DNS operator's certificate) acting as a verifier or performed by an
      external Verifier (signed by that external Verifier). The signing
      certificate can to be an Extended Validation (EV) certificate issued by
      a public CA in specific scenarios listed below. An EV certificate is
      issued by the public CA after a thorough Background Check to verify the
      requesting organization's legal identity. If the signing certificate is
      a EV certificate, it leaves the client with a better audit trail of the
      organization hosting the DNS server in comparison with the DV
      certificate.</t>

      <t>The use of EV certificate is needed in the following scenarios:</t>

      <t><list style="symbols">
          <t>It helps the client to avoid sending DNS queries to an Encrypted
          DNS server hosted by an attacker discovered insecurely (e.g., using
          DHCP/RA or DNS). For example, an attacker can get a domain name,
          domain-validated public certificate from a CA and host a Encrypted
          DNS server. Furthermore, an attacker can use a public IP address,
          get an 'IP address'-validated public certificate from a CA and host
          a Encrypted DNS server.</t>

          <t>It can be used by the client to identify the Encrypted DNS server
          is hosted by a legal organization.</t>
        </list></t>

      <t>The use of EV certificate is not required in the following
      scenarios:</t>

      <t><list style="symbols">
          <t>If the Encrypted DNS server can only be discovered securely
          (e.g., using IKEv2 <xref target="I-D.btw-add-ipsecme-ike"></xref>),
          the signing certificate need not be an EV certificate.</t>

          <t>Secure Zero Touch Provisioning <xref target="RFC8572"></xref>
          defines a bootstrapping strategy for enabling a networking device to
          securely obtain the required configuration information with no user
          input. If the encrypted DNS server is insecurely discovered and not
          preconfigured in the networking device, the DNS client on the
          networking device can validate the Resolver Assertion Token
          signature using the owner certificate as per Section 3.2 of <xref
          target="RFC8572"></xref>.</t>
        </list></t>

      <t>JSON Web Token (JWT) <xref target="RFC7519"></xref> and JSON Web
      Signature (JWS) <xref target="RFC7515"></xref> and related
      specifications define a standard token format that can be used as a way
      of encapsulating claimed or asserted information with an associated
      digital signature using X.509 based certificates. JWT provides a set of
      claims in JSON format that can accommodate asserted resolver information
      of the Encrypted DNS server. Additionally, JWS provides a path for
      updating methods and cryptographic algorithms used for the associated
      digital signatures.</t>

      <t>JWS defines the use of JSON data structures in a specified canonical
      format for signing data corresponding to JOSE header, JWS Payload, and
      JWS Signature. The next sections define the header and claims that MUST
      be minimally used with JWT and JWS for resolver assertion token.</t>

      <t>The Resolver Assertion Token (RAT) specifically uses this token
      format and defines claims that convey the resolver information of
      Encrypted DNS server.</t>

      <t>The client can retrieve the RAT object using the RESINFO RRtype
      defined in <xref target="I-D.pp-add-resinfo"></xref> and QNAME of the
      domain name that is used to authenticate the DNS server (referred to as
      ADN in <xref target="RFC8310"></xref>). If the special use domain name
      "resolver.arpa" defined in [I-D.ietf-add-ddr] is used to discover the
      Encrypted DNS server, the client can retrieve the RAT object using the
      RESINFO RRtype and QNAME of the special use domain name.</t>

      <t>The signature of RAT object MUST be validated by the DNS client. If
      signature is invalid, the RAT object is rejected. If signature is valid
      and signer is trusted, the DNS client can use that encrypted DNS
      server.</t>
    </section>

    <section anchor="pat_header" title="RAT Header">
      <t>The JWS token header is a JOSE header (Section 4 of <xref
      target="RFC7515"></xref>) that defines the type and encryption algorithm
      used in the token.</t>

      <t>The RAT header MUST include, at a minimum, the header parameters
      defined in Sections <xref format="counter"
      target="typ-type-header-parameter"></xref>, <xref format="counter"
      target="alg-algorithm-header-parameter"></xref>, and <xref
      format="counter" target="x5u-x509-url-header-parameter"></xref>.</t>

      <section anchor="typ-type-header-parameter"
               title="'typ' (Type) Header Parameter">
        <t>The 'typ' (Type) Header Parameter is defined in Section 4.1.9 of
        <xref target="RFC7515"></xref> to declare the media type of the
        complete JWS.</t>

        <t>For RAT Token the 'typ' header MUST be the string 'rat'. This
        represents that the encoded token is a JWT of type rat.</t>
      </section>

      <section anchor="alg-algorithm-header-parameter"
               title="'alg' (Algorithm) Header Parameter">
        <t>The 'alg' (Algorithm) Header Parameter is defined in Section 4.1.1
        of <xref target="RFC7515"></xref>. It specifies the JWS signature
        cryptographic algorithm. It also refers to a list of defined 'alg'
        values as part of a registry established by JSON Web Algorithms (JWA)
        <xref target="RFC7518"></xref> Section 3.1.</t>

        <t>For the creation and verification of RAT tokens and their digital
        signatures, implementations MUST support ES256 as defined in Section
        3.4 of <xref target="RFC7518"></xref>. Implementations MAY support
        other algorithms registered in the JSON Web Signature and Encryption
        Algorithms registry created by <xref target="RFC7518"></xref>. The
        content of that registry may be updated in the future depending on
        cryptographic strength requirements guided by current security best
        practice. The mandatory-to-support algorithm for RAT tokens may
        likewise be updated in the future.</t>

        <t>Implementations of RAT digital signatures using ES256 as defined
        above SHOULD use deterministic ECDSA when supported for the reasons
        stated in <xref target="RFC6979"></xref>.</t>
      </section>

      <section anchor="x5u-x509-url-header-parameter"
               title="'x5u' (X.509 URL) Header Parameter">
        <t>As defined in Section 4.1.5 of <xref target="RFC7515"></xref>, the
        'x5u' header parameter defines a URI <xref target="RFC3986"></xref>
        referring to the resource for the X.509 public key certificate or
        certificate chain <xref target="RFC5280"></xref> corresponding to the
        key used to digitally sign the JWS. Generally, as defined in Section
        4.1.5 of <xref target="RFC7515"></xref> this corresponds to an HTTPS
        or DNSSEC resource using integrity protection.</t>
      </section>

      <section anchor="example-pat-header" title="An Example of RAT Header">
        <t>An example of the RAT header is shown in <xref target="ex"></xref>.
        It includes the specified RAT type, ES256 algorithm, and an URI
        referencing the network location of the certificate needed to validate
        the RAT signature.</t>

        <figure align="center" anchor="ex" title="A RAT Header Example">
          <artwork><![CDATA[{
  "typ":"rat",
  "alg":"ES256",
  "x5u":"https://cert.example.com/rat.cer"
}
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="pat_payload" title="RAT Payload">
      <t>The token claims consist of the resolver information of the DNS
      server that needs to be verified at the DNS client. These claims follow
      the definition of a JWT claim (Section 4 of <xref
      target="RFC7519"></xref>) and are encoded as defined by the JWS Payload
      (Section 3 of <xref target="RFC7515"></xref>).</t>

      <t>RAT defines the use of a standard JWT-defined claim as well as custom
      claims corresponding to the DoT or DoH servers.</t>

      <t>Claim names MUST use the US-ASCII character set. Claim values MAY
      contain characters that are outside the ASCII range, however they MUST
      follow the default JSON serialization defined in Section 7 of <xref
      target="RFC7519"></xref>.</t>

      <section anchor="jwt-defined-claims" title="JWT Defined Claims">
        <section anchor="iat-issued-at-claim" title="'iat' - Issued At Claim">
          <t>The JSON claim MUST include the 'iat' (Section 4.1.6 of <xref
          target="RFC7519"></xref>) defined claim "Issued At". The 'iat'
          should be set to the date and time of issuance of the JWT. The time
          value should be of the format (NumericDate) defined in Section 2 of
          <xref target="RFC7519"></xref>.</t>
        </section>

        <section anchor="exp-header-parameter"
                 title="'exp' - Expiration Time Claim">
          <t>The JSON claim MUST include the 'exp' (Section 4.1.4 of <xref
          target="RFC7519"></xref>) defined "claim Expiration Time". The 'exp'
          should be set to specify the expiration time on or after which the
          JWT is not accepted for processing. The RAT object should expire
          after a reasonable duration. A short expiration time for the RAT
          object periodically reaffirms the resolver information of the DNS
          server to the DNS client and ensures the DNS client does not use
          outdated resolver information. If the DNS client knows the RAT
          object has expired, it should make another request to get the new
          RAT object from the DNS server.</t>
        </section>
      </section>

      <section anchor="pat_claims" title="RAT Specific Claims">
        <section anchor="server-identity" title="DNS Server Identity Claims">
          <t>The DNS server identity is represented by a claim that is
          required for RAT: the 'server' claim. The 'server' MUST contain
          claim values that are identity claim JSON objects where the child
          claim name represents an identity type and the claim value is the
          identity string, both defined in subsequent subsections.</t>

          <t>These identities can be represented as either authentication
          domain name (ADN) (defined in <xref target="RFC8310"></xref>) or
          Uniform Resource Indicators (URI).</t>

          <t>The DNS client constructs a reference identifier for the DNS
          server based on the ADN or the domain portion in the URI of the DNS
          server identity. The domain name in the DNS-ID identifier type
          within subjectAltName entry in the DNS server certificate conveyed
          in the TLS handshake is matched with the reference identifier. If
          the match is not successful, the client MUST not accept the RAT for
          further processing.</t>

          <section anchor="adn"
                   title="'adn' - Authentication Domain Name Identity">
            <t>If the DNS server identity is an ADN, the claim name
            representing the identity MUST be 'adn'. The claim value for the
            'adn' claim is the ADN.</t>
          </section>

          <section anchor="uri-identity" title="'uri' - URI Identity">
            <t>If the DNS server identity is of the form URI Template, as
            defined in <xref target="RFC6570"></xref>, the claim name
            representing the identity MUST be 'uri' and the claim value is the
            URI Template form of the DNS server identity.</t>

            <t>As a reminder, if DoH is supported by the DNS server, the DNS
            client uses the URI Template (Section 3 of <xref
            target="RFC8484"></xref>).</t>
          </section>
        </section>

        <section anchor="policyinfo"
                 title="'resinfo' (Resolver Information) Claim">
          <t>The 'resinfo' claim MUST be formatted as a JSON object. The JSON
          object MUST use the I-JSON message format defined in <xref
          target="RFC7493"></xref>. Note that <xref target="RFC7493"></xref>
          was based on <xref target="RFC7159"></xref>, but <xref
          target="RFC7159"> </xref> was replaced by <xref
          target="RFC8259"></xref>. Requiring the use of I-JSON instead of
          more general JSON format greatly increases the likelihood of
          interoperability.</t>

          <t>The 'resinfo' claim contains the resolver information of the DNS
          server, it includes the following attributes:</t>

          <t><list style="hanging">
              <t hangText="qnameminimization:">If the DNS server supports
              QNAME minimisation <xref target="RFC7816"></xref> to improve DNS
              privacy, the parameter value is set to true. This is a mandatory
              attribute.</t>

              <t hangText="extendeddnserror:">If the DNS server supports
              extended DNS error (EDE) <xref target="RFC8914"></xref> to
              return additional information about the cause of DNS errors, the
              parameter lists the possible extended DNS error codes that can
              be returned by the DNS server. This is an optional attribute.
              <list style="symbols">
                  <t>Note that the extended error code "Blocked" defined in
                  Section 4.16 of <xref target="RFC8914"></xref> identifies
                  access to domains is blocked due to an policy by the
                  operator of the DNS server, extended error code "Censored"
                  defined in Section 4.17 of <xref target="RFC8914"></xref>
                  identifies access to domains is blocked based on a
                  requirement from an external entity and the extended error
                  code "Filtered" defined in Section 4.18 of <xref
                  target="RFC8914"></xref> identifies access to domains is
                  blocked based on the request from the client to blacklist
                  domains. </t>

                  <t>Extended error code "Threat Blocking" defined in <xref
                  target="threat-blocking"></xref> identifies access to
                  domains is blocked to protect from security threats. Note
                  that some of the commonly known types of threats are
                  malware, phishing, viruses, worms, trojans, bots,
                  ransomware, backdoors, spyware, and adware. </t>
                </list></t>

              <t hangText="clientauth:">If the DNS server requires client
              authentication, the parameter value is set to true. For example,
              when not on the enterprise network (e.g., at home or coffee
              shop) yet needing to access the enterprise Encrypted DNS server,
              roaming users can use client authentication to access the
              Enterprise provided Encrypted DNS server. This is an optional
              attribute.</t>

              <t hangText="resinfourl:">A URL that points to the generic
              unstructured resolver information (e.g., DoH APIs supported,
              possible HTTP status codes returned by the DoH server, how to
              report a problem, etc.) for troubleshooting purpose. This is an
              optional attribute.</t>

              <t hangText="identityurl:">A URL that points to a human-friendly
              description of the resolver identity to display to the
              end-user.</t>
            </list></t>
        </section>

        <section anchor="pat_payload_example" title="An Example">
          <t><xref target="poex"></xref> shows an example of resolver
          information.</t>

          <figure anchor="poex" title="An Example of Resolver Information">
            <artwork><![CDATA[{
  "server":{
      "adn":"example.com"
  },
  "iat":1443208345,
  "exp":1443640345,
  "resinfo": {
     "qnameminimization":false,
  } 
}
]]></artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="pat_signature" title="RAT Signature">
      <t>The signature of the RAT is created as specified in Section 5.1 of
      <xref target="RFC7515"></xref> (Steps 1 through 6). RAT MUST use the JWS
      Protected Header.</t>

      <t>For the JWS Payload and the JWS Protected Header, the lexicographic
      ordering and white space rules described in <xref
      target="pat_header"></xref> and <xref target="pat_payload"></xref>, and
      JSON serialization rules in <xref target="json_serialization"></xref>
      MUST be followed.</t>

      <t>The RAT is cryptographically signed by the domain hosting the DNS
      server and optionally by a third party who performed privacy and
      security audit of the DNS server.</t>

      <t>The resolver information is attested using "Extended Validation" (EV)
      certificate to avoid bad actors taking advantage of this mechanism to
      advertise encrypted DNS servers for illegitimate and fraudulent purposes
      meant to trick DNS clients into believing that they are using a
      legitimate encrypted DNS server hosted to provide privacy for DNS
      transactions.</t>

      <t>Alternatively, a DNS client has to be configured to trust the leaf of
      the signer of the RAT object. That is, trust of the signer MUST NOT be
      determined by validating the signer via the OS or the browser trust
      chain because that would allow any arbitrary entity to operate a DNS
      server and assert any sort of resolver information.</t>

      <t><xref
      target="example-es256-based-pat-jws-serialization-and-signature"></xref>
      provides an example of how to follow the steps to create the JWS
      Signature.</t>

      <t>JWS JSON serialization (Step 7 in Section 5.1 of <xref
      target="RFC7515"></xref>) is supported for RAT to enable multiple
      signatures to be applied to the RAT object. For example, the RAT object
      can be cryptographically signed by the domain hosting the DNS server and
      by a third party who performed privacy and security audit of the DNS
      server.</t>

      <t><xref
      target="example-es256-based-pat-jws-serialization-and-signatures"></xref>
      includes an example of the full JWS JSON serialization representation
      with multiple signatures.</t>

      <t>Section 5.1 of <xref target="RFC7515"></xref> (Step 8) describes the
      method to create the final JWS Compact Serialization form of the RAT
      Token.</t>
    </section>

    <section anchor="extending_pat" title="Extending RAT">
      <t>RAT includes the minimum set of claims needed to securely assert the
      resolver information of the DNS server. JWT supports a mechanism to add
      additional asserted or signed information by simply adding new claims.
      RAT can be extended beyond the defined base set of claims to represent
      other DNS server information requiring assertion or validation.
      Specifying new claims follows the baseline JWT procedures (<xref
      target="RFC7519">Section 10.1 of </xref>). Understanding new claims on
      the DNS client is optional. The creator of a RAT object cannot assume
      that the DNS client will understand the new claims.</t>
    </section>

    <section anchor="json_serialization"
             title="Deterministic JSON Serialization">
      <t>JSON objects can include spaces and line breaks, and key value pairs
      can occur in any order. It is therefore a non-deterministic string
      format. In order to make the digital signature verification work
      deterministically, the JSON representation of the JWS Protected Header
      object and JWS Payload object MUST be computed as follows.</t>

      <t>The JSON object MUST follow the following rules. These rules are
      based on the thumbprint of a JSON Web Key (JWK) as defined in Section 3
      of <xref target="RFC7638"></xref> (Step 1).</t>

      <t><list style="numbers">
          <t>The JSON object MUST contain no whitespace or line breaks before
          or after any syntactic elements.</t>

          <t>JSON objects MUST have the keys ordered lexicographically by the
          Unicode <xref target="UNICODE"></xref> code points of the member
          names.</t>

          <t>JSON value literals MUST be lowercase.</t>

          <t>JSON numbers are to be encoded as integers unless the field is
          defined to be encoded otherwise.</t>

          <t>Encoding rules MUST be applied recursively to member values and
          array values.</t>
        </list></t>

      <section anchor="example-pat-deterministic-json-form"
               title="Example RAT Deterministic JSON Form">
        <t>This section demonstrates the deterministic JSON serialization for
        the example RAT Payload shown in <xref
        target="pat_payload_example"></xref>.</t>

        <t>The initial JSON object is shown in <xref
        target="initial"></xref>.</t>

        <figure anchor="initial" title="Initial JSON Object">
          <artwork><![CDATA[{
  "server":{
      "adn":"example.com"
  },
  "iat":1443208345,
  "exp":1443640345,
  "resinfo": {
     "qnameminimization":false,
  } 
}
]]></artwork>
        </figure>

        <t>The parent members of the JSON object are as follows, in
        lexicographic order: "exp", "iat", "resinfo", "server".</t>

        <t>The final constructed deterministic JSON serialization
        representation, with whitespace and line breaks removed, (with line
        breaks used for display purposes only) is:</t>

        <figure anchor="final" title="Deterministic JSON Form">
          <artwork><![CDATA[{"exp":1443640345,"iat":1443208345,
"resinfo":{"qnameminimization":false},
"server":{"adn":"example.com"}}
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="Identity" title="Using RESINFO Responses">
      <t>This document defines the following entries for the IANA DNS Resolver
      Information Registry that is defined in <xref
      target="I-D.pp-add-resinfo"></xref>.</t>

      <t><list style="numbers">
          <t>The "server" name containing the DNS server identity discussed in
          <xref target="PAT"></xref>.</t>

          <t>The sub-attribute "adn" discussed in <xref target="PAT"></xref>
          contained in the "server" attribute is used to specify the DNS
          server identity in the form of ADN.</t>

          <t>The sub-attribute "uri" discussed in <xref target="PAT"></xref>
          contained in the "server" attribute is used to specify the DNS
          server identity in the form of URI template.</t>

          <t>The "resinfourl", "extendeddnserror" and "qnameminimization"
          names containing the resolver information of the DNS server
          discussed in <xref target="PAT"></xref>.</t>

          <t>The "attested-resinfo" name contains a base64 encoding of a RAT
          <xref target="PAT"></xref>. If the "attested-resinfo" name is
          conveyed to the client, the server need not convey the above
          attributes (1 to 5) separately as that resolver information will be
          extracted by the client from the RAT payload.</t>
        </list></t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The use of RAT object based on the validation of the digital
      signature and the associated certificate requires consideration of the
      authentication and authority or reputation of the signer to attest the
      resolver information of the DNS server being asserted. Bad actors can
      host encrypted DNS servers to invade the privacy of the user. Bad actor
      can get a domain name, host encrypted DNS servers, and get the DNS
      server certificate signed by a CA. The resolver information will have to
      be attested using EV certificates or a RAT object signer trusted by the
      DNS client to prevent the attack.</t>

      <t>The CA that issued the EV certificate does not attest the resolver
      information. The organization hosting the DNS server attests the
      resolver information using the EV certificate and the client uses the EV
      certificate to identify the organization (e.g., ISP or Enterprise)
      hosting the DNS server.</t>

      <t>If the RAT object is asserted by a third party, it can do a "time of
      check" but the DNS server is susceptible of "time of use" attack. For
      example, changes to the DNS server can cause a disagreement between the
      auditor and the DNS server operation, hence the RAT object needs to be
      also asserted by the domain hosting the DNS server. In addition, the RAT
      object needs to have a short expiration time (e.g., 7 days) to ensure
      the DNS server's domain re-asserts the resolver information and limits
      the damage from change in behaviour and mis-issuance.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <section anchor="media-type-registration"
               title="Media Type Registration">
        <section anchor="media-type-registry-contents-additions-requested"
                 title="Media Type Registry Contents Additions Requested">
          <t>This section registers the 'application/rat' media type <xref
          target="RFC2046"></xref> in the 'Media Types' registry in the manner
          described in <xref target="RFC6838"></xref>, which can be used to
          indicate that the content is a RAT defined JWT.</t>

          <t><list style="symbols">
              <t>Type name: application</t>

              <t>Subtype name: rat</t>

              <t>Required parameters: n/a</t>

              <t>Optional parameters: n/a</t>

              <t>Encoding considerations: 8bit; application/rat values are
              encoded as a series of base64url-encoded values (some of which
              may be the empty string) separated by period (&lsquo;.&rsquo;)
              characters..</t>

              <t>Security considerations: See the Security Considerations
              Section of <xref target="RFC7515"></xref>.</t>

              <t>Interoperability considerations: n/a</t>

              <t>Published specification: [THIS_DOCUMENT]</t>

              <t>Applications that use this media type: DNS</t>

              <t>Fragment identifier considerations: n/a</t>

              <t>Additional information: <vspace blankLines="1" /> Magic
              number(s): n/a File extension(s): n/a Macintosh file type
              code(s): n/a</t>

              <t>Person &amp; email address to contact for further
              information: Tirumaleswar Reddy, kondtir@gmail.com</t>

              <t>Intended usage: COMMON</t>

              <t>Restrictions on usage: none</t>

              <t>Author: Tirumaleswar Reddy, kondtir@gmail.com</t>

              <t>Change Controller: IESG</t>

              <t>Provisional registration? No</t>
            </list></t>
        </section>
      </section>

      <section anchor="json-web-token-claims-registration"
               title="JSON Web Token Claims Registration">
        <section anchor="registry-contents-additions-requested"
                 title="Registry Contents Additions Requested">
          <t>IANA is requested to assign the following claims in the registry
          maintained in: https://www.iana.org/assignments/jwt/jwt.xhtml.<list
              style="symbols">
              <t>Claim Name: 'server'</t>

              <t>Claim Description: DNS server identity</t>

              <t>Change Controller: IESG</t>

              <t>Specification Document(s): <xref
              target="server-identity"></xref> of [THIS_DOCUMENT]</t>

              <t>Claim Name: 'resinfo'</t>

              <t>Claim Description: Resolver information of DNS server.</t>

              <t>Change Controller: IESG</t>

              <t>Specification Document(s): <xref target="policyinfo"></xref>
              of [THIS_DOCUMENT]</t>
            </list></t>
        </section>
      </section>

      <section anchor="resolver-information"
               title="DNS Resolver Information Registration">
        <t>IANA will add the names "attested-resinfo", "server", "resinfourl",
        "identityurl", "extendeddnserror" and "qnameminimization" to the DNS
        Resolver Information registry defined in Section 4.2 of <xref
        target="I-D.pp-add-resinfo"></xref>.</t>

        <t>IANA will add "adn" and "uri" sub-attributes contained in the
        "server" attribute to the DNS Resolver Information registry.</t>
      </section>

      <section anchor="threat-blocking"
               title="Threat Blocking Extended DNS Error Code">
        <t>IANA is requested to add Extended DNS Error Code for "Threat
        Blocking" in the registry for Extended DNS Error Codes.</t>
      </section>
    </section>

    <section anchor="acknowledgments" title="Acknowledgments">
      <t>This specification leverages some of the work that has been done in
      <xref target="RFC8225"></xref>. Thanks to Tommy Jensen, Ted Lemon, Paul
      Wouters, Neil Cook, Vittorio Bertola, Vinny Parla, Chris Box, Ben
      Schwartz and Shashank Jain for the discussion and comments.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include='reference.RFC.8174'?>

      <?rfc include="reference.RFC.8484"?>

      <?rfc include="reference.RFC.8499"?>

      <?rfc include="reference.RFC.5280"?>

      <?rfc include="reference.RFC.7515"?>

      <?rfc include="reference.RFC.7519"?>

      <?rfc include="reference.RFC.7518"?>

      <?rfc include="reference.RFC.6979"?>

      <?rfc include="reference.RFC.6570"?>

      <?rfc include="reference.RFC.7638"?>

      <?rfc include="reference.RFC.6838"?>

      <?rfc include="reference.RFC.2046"?>

      <?rfc include="reference.RFC.7858"?>

      <?rfc include="reference.RFC.3986"?>

      <?rfc include="reference.RFC.7493"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.8310"?>

      <?rfc include='reference.I-D.ietf-rats-architecture'?>

      <?rfc include='reference.I-D.ietf-dprive-dnsoquic' 
?>

      <?rfc include='reference.I-D.btw-add-ipsecme-ike"?>

      <?rfc include="reference.RFC.7626"?>

      <?rfc include="reference.RFC.7816"?>

      <?rfc include="reference.RFC.8225"?>

      <?rfc include="reference.RFC.8572"?>

      <?rfc include='reference.I-D.btw-add-home'?>

      <?rfc include='reference.I-D.pp-add-resinfo'?>

      <?rfc include='reference.RFC.8914' ?>

      <?rfc include='reference.RFC.8259' ?>

      <?rfc include='reference.RFC.7159' ?>

      <?rfc include='reference.I-D.ietf-dnsop-terminology-ter'?>

      <reference anchor="UNICODE"
                 target="http://www.unicode.org/versions/latest/">
        <front>
          <title>The Unicode Standard</title>

          <author>
            <organization>The Unicode Consortium</organization>
          </author>

          <date day="21" month="June" year="2016" />
        </front>
      </reference>
    </references>

    <section anchor="example-es256-based-pat-jws-serialization-and-signature"
             title="Example of ES256-based RAT JWS Serialization and Signature">
      <t>For RAT, there will always be a JWS with the following members:</t>

      <t><list style="symbols">
          <t>'protected', with the value BASE64URL(UTF8(JWS Protected
          Header))</t>

          <t>'payload', with the value BASE64URL (JWS Payload)</t>

          <t>'signature', with the value BASE64URL(JWS Signature)</t>
        </list></t>

      <t>This example will follow the steps in JWS <xref
      target="RFC7515"></xref> Section 5.1, steps 1-6 and 8 and incorporates
      the additional serialization steps required for RAT.</t>

      <t>Step 1 for JWS references the JWS Payload, an example RAT Payload is
      as follows:</t>

      <figure>
        <artwork><![CDATA[{
  "server":{
      "adn":"example.com"
  },
  "iat":1443208345,
  "exp":1443640345,
  "resinfo": {
     "qnameminimization":false
  } 
}
]]></artwork>
      </figure>

      <t>This would be serialized to the form (with line break used for
      display purposes only):</t>

      <figure>
        <artwork><![CDATA[{"exp":1443640345,"iat":1443208345,"resinfo":{
"qnameminimization":false},"server":{"adn":"example.com"}}
]]></artwork>
      </figure>

      <t>Step 2 Computes the BASE64URL(JWS Payload) producing this value (with
      line break used for display purposes only):</t>

      <figure>
        <artwork><![CDATA[
eyJleHAiOjE0NDM2NDAzNDUsImlhdCI6MTQ0MzIwODM0NSwicmVzaW5mbyI6ey
JxbmFtZW1pbmltaXphdGlvbiI6ZmFsc2V9LCJzZXJ2ZXIiOnsiYWRuIjoiZXhh
bXBsZS5jb20ifX0


]]></artwork>
      </figure>

      <t>For Step 3, an example RAT Protected Header comprising the JOSE
      Header is as follows:</t>

      <figure>
        <artwork><![CDATA[{
  "alg":"ES256",
  "typ":"rat",
  "x5u":"https://cert.example.com/rat.cer"
}
]]></artwork>
      </figure>

      <t>This would be serialized to the form (with line break used for
      display purposes only):</t>

      <figure>
        <artwork><![CDATA[
{"alg":"ES256","typ":"rat","x5u":"https://cert.example.com
/rat.cer"}
]]></artwork>
      </figure>

      <t>Step 4 Performs the BASE64URL(UTF8(JWS Protected Header)) operation
      and encoding produces this value (with line break used for display
      purposes only):</t>

      <figure>
        <artwork><![CDATA[
eyJhbGciOiJFUzI1NiIsInR5cCI6InJhdCIsIng1dSI6Imh0dHBzOi8vY2VydC5l
eGFtcGxlLmNvbS9yYXQuY2VyIn0


]]></artwork>
      </figure>

      <t>Step 5 and Step 6 performs the computation of the digital signature
      of the RAT Signing Input ASCII(BASE64URL(UTF8(JWS Protected Header)) ||
      &lsquo;.&rsquo; || BASE64URL(JWS Payload)) using ES256 as the algorithm
      and the BASE64URL(JWS Signature).</t>

      <figure>
        <artwork><![CDATA[

d1g7szj0roHsWe8psCzYVl4QdN2b7pQnq8EJhc4j3GOJj2NE6M9Em6aidtycnFJ5
mRj3ojiUfVF6rK5RksD0rg


]]></artwork>
      </figure>

      <t>Step 8 describes how to create the final RAT token, concatenating the
      values in the order Header.Payload.Signature with period
      (&lsquo;.&rsquo;) characters. For the above example values this would
      produce the following (with line breaks between period used for
      readability purposes only):</t>

      <figure>
        <artwork><![CDATA[eyJhbGciOiJFUzI1NiIsInR5cCI6InJhdCIsIng1dSI6Imh0dHBzOi8vY2VydC5l
eGFtcGxlLmNvbS9yYXQuY2VyIn0
.

eyJhbGciOiJFUzI1NiIsInR5cCI6InJhdCIsIng1dSI6Imh0dHBzOi8vY2VydC5l
eGFtcGxlLmNvbS9yYXQuY2VyIn0
.
d1g7szj0roHsWe8psCzYVl4QdN2b7pQnq8EJhc4j3GOJj2NE6M9Em6aidtycnFJ5
mRj3ojiUfVF6rK5RksD0rg

]]></artwork>
      </figure>

      <section anchor="x509-private-key-in-pkcs8-format-for-es256-example"
               title="X.509 Private Key in PKCS#8 Format for ES256 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgevZzL1gdAFr88hb2
OF/2NxApJCzGCEDdfSp6VQO30hyhRANCAAQRWz+jn65BtOMvdyHKcvjBeBSDZH2r
1RTwjmYSi9R/zpBnuQ4EiMnCqfMPWiZqB4QdbAd0E7oH50VpuZ1P087G
-----END PRIVATE KEY-----
]]></artwork>
        </figure>
      </section>

      <section anchor="x509-public-key-for-es256-example"
               title="X.509 Public Key for ES256 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEVs/o5+uQbTjL3chynL4wXgUg2R9
q9UU8I5mEovUf86QZ7kOBIjJwqnzD1omageEHWwHdBO6B+dFabmdT9POxg==
-----END PUBLIC KEY-----
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="example-es256-based-pat-jws-serialization-and-signatures"
             title="Complete JWS JSON Serialization Representation with multiple Signatures">
      <t>The JWS payload used in this example as follows.</t>

      <t><figure>
          <artwork><![CDATA[{
  "server":{
      "adn":"example.com"
  },
  "iat":1443208345,
  "exp":1443640345,
  "resinfo": {
     "qnameminimization":false
  } 
}
]]></artwork>
        </figure></t>

      <t>This would be serialized to the form (with line break used for
      display purposes only):</t>

      <figure>
        <artwork><![CDATA[{"exp":1443640345,"iat":1443208345,"resinfo":{
"qnameminimization":false},"server":{"adn":"example.com"}}
]]></artwork>
      </figure>

      <t></t>

      <t>The JWS protected Header value used for the first signature is same
      as that used in the example in <xref
      target="example-es256-based-pat-jws-serialization-and-signature"></xref>.
      The X.509 private key used for generating the first signature is same as
      that used in the example in <xref
      target="x509-private-key-in-pkcs8-format-for-es256-example"></xref>.</t>

      <t>The JWS Protected Header value used for the second signature is:</t>

      <t><figure>
          <artwork><![CDATA[{
  "alg":"ES384",
  "typ":"rat",
  "x5u":"https://cert.audit-example.com/rat.cer"
}
]]></artwork>
        </figure></t>

      <t>The complete JWS JSON Serialization for these values is as follows
      (with line breaks within values for display purposes only):</t>

      <figure>
        <artwork><![CDATA[{
  "payload":
       "eyJhbGciOiJFUzI1NiIsInR5cCI6InJhdCIsIng1dSI6Imh0dHBzOi8vY2VydC5l
        eGFtcGxlLmNvbS9yYXQuY2VyIn0",
  "signatures":[
       {"protected":"eyJhbGciOiJFUzI1NiIsInR5cCI6InJhdCIsIng1dSI6Imh0dHBz
        Oi8vY2VydC5leGFtcGxlLmNvbS9yYXQuY2VyIn0",
        "signature":"d1g7szj0roHsWe8psCzYVl4QdN2b7pQnq8EJhc4j3GOJj2NE6M9E
        m6aidtycnFJ5mRj3ojiUfVF6rK5RksD0rg"},
       {"protected":"eyJhbGciOiJFUzM4NCIsInR5cCI6InJhdCIsIng1dSI6Imh0dHB
        zOi8vY2VydC5hdWRpdC1leGFtcGxlLmNvbS9yYXQuY2VyIn0",
        "signature":"GnKuEEFql_Y8HdZl_mqd027DlziGRXFHvjMoY_ukX-M0k5v2jSL
        vsQAYOGdKFnt3JY6t938HfBV1onsWerNhgceMJpx5hAsl-xus3fmNY8K1g6QK39
        hn2Dhbleeeyp0f"}]   
}
]]></artwork>
      </figure>

      <section anchor="x509-private-key-in-pkcs8-format-for-es384-example"
               title="X.509 Private Key in PKCS#8 format for E384 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgevZzL1gdAFr88hb2
OF/2NxApJCzGCEDdfSp6VQO30hyhRANCAAQRWz+jn65BtOMvdyHKcvjBeBSDZH2r
1RTwjmYSi9R/zpBnuQ4EiMnCqfMPWiZqB4QdbAd0E7oH50VpuZ1P087G
-----END PRIVATE KEY-----
]]></artwork>
        </figure>
      </section>

      <section anchor="x509-public-key-for-es384-example"
               title="X.509 Public Key for ES384 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEVs/o5+uQbTjL3chynL4wXgUg2R9
q9UU8I5mEovUf86QZ7kOBIjJwqnzD1omageEHWwHdBO6B+dFabmdT9POxg==
-----END PUBLIC KEY-----
]]></artwork>
        </figure>
      </section>
    </section>
  </back>
</rfc>
